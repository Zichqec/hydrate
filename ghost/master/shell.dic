OnShellChanging
{
	//This gets the current ghost coordinates so that they don't jump around the screen when they change shells
	if Config.MatchShellPosition
	{
		"\![get,property,OnGetCoordsBefore,currentghost.scope(0).rect,currentghost.scope(0).y]"
	}
}

OnShellChanged
{
	if Config.MatchShellPosition
	{
		"\0\s[-1]\![get,property,OnGetCoordsAfter,currentghost.scope(0).rect,currentghost.scope(0).y]"
	}
	else; ShellChangedEnd
}

OnGetCoordsBefore //This gets the x coordinate
{
	ShellChange.BeforeX = reference0[0] //Horizontal position
	ShellChange.BeforeFeet = reference1 //Feet height
}

OnGetCoordsAfter : all
{
	//Take the feet height and subtract the height after it because we want to get how far above the feet height the Y coordinate needs to be to place the bottom where it needs to land!
	_AfterHeight = TOINT(reference1) - TOINT(reference0[1]) //Distance between feet and top
	_FinalY = TOINT(ShellChange.BeforeFeet) - TOINT(_AfterHeight) //Should be the new position where the top must go to make the feet be in the right spot
	
	AutoUpdates.ShellReady = 0
	
	"\0\![move,--X=%(ShellChange.BeforeX),--Y=%(_FinalY),--base=primaryscreen]"
	
	ERASEVAR("ShellChange.BeforeX","ShellChange.BeforeFeet")
	
	ShellChangedEnd
}

ShellChangedEnd : all
{
	AutoShell.LastChangeTime = GETSECCOUNT
	AutoDressup.LastChangeTime = GETSECCOUNT
	
	if Config.AutoDressupChange == "When shell changes"; "\![embed,OnRandomDressup]"
	
	OnGetShellAuthorInfo
	OnSendStats
	
	"\1\s[-1]\0\s[0]"
	
	if Config.AutoUpdates; "\![update,shell,checkonly]"
	
	if AutoShell.ChangingOnBoot
	{
		AutoShell.ChangingOnBoot = 0
		BootFinish
	}
	elseif SHIORI3FW.ShellName == SHIORI3FW.ShellNameOld
	{
		"(Reloaded %(SHIORI3FW.ShellName)!)"
	}
	elseif SHIORI3FW.ShellName == "Clear" //Default
	{
		"(Default water.)"
	}
	else
	{
		"(Now using %(SHIORI3FW.ShellName).)"
		"\w8\w8\n\n"
		
		if Config.ShellChangeComments; ShellChangeComments
	}
}

OnGetShellAuthorInfo
{
	"\![get,property,OnShellAuthor,currentghost.shelllist.current.craftmanw,currentghost.shelllist.current.craftman,currentghost.shelllist.current.craftmanurl]"
}

OnShellAuthor
{
	shellauthor[0] = reference0 //craftmanw
	shellauthor[1] = reference1 //craftman -- i THINK that this is automatically using craftmanw when not present? There's no other way to explain this behavior. It's not documented on Ukadoc... yet
	shellauthor[2] = reference2 //craftmanurl
}

//character ID, category name, part name, option, on-1/off-0, thumbnail path
OnNotifyDressupInfo
{
	dressups.available = IARRAY //This one is to display the dressup menu
	dressups.current = IARRAY //This one is so we can display which dressups are currently in use
	
	//Has to be reference.raw because parts of this are delimited with C_BYTE1
	foreach reference.raw; _dressup
	{
		_dressup = SPLIT(_dressup,C_BYTE1)
		
		_toadd = _dressup[1] + C_BYTE1 + _dressup[2]
		if _dressup[4] == 1; dressups.current ,= _toadd
		
		if _dressup[3] != ""; _toadd += C_BYTE1 + _dressup[3]
		dressups.available ,= _toadd
	}
}

OnDressupChanged
{
	//Because this runs BEFORE the notify event above, add a delay so that the changes are processed before sending stats...
	if BalloonIsOpen; "\C\![timerraise,100,1,OnSendStats,balloonopen]"
	elseif reference4 == "user"; "\![timerraise,100,1,OnSendStats]"
}

OnRandomDressup : all
{
	AutoDressup.LastChangeTime = GETSECCOUNT
	
	_currentcategory = reference0
	_returnto = reference1
	
	if _returnto != ""; "\C\![lock,balloonrepaint]\![set,autoscroll,disable]"
	"\0\_q"
	
	//—— Unbind all active ——
	//ID, category, name
	foreach dressups.current; _dressup
	{
		"\![bind,%(_dressup[1,C_BYTE1]),%(_dressup[2,C_BYTE1]),0]"
	}
	
	//—— Break dressups into categories ——
	_category.key = IARRAY
	_category.val = IARRAY
	_category.opt = IARRAY
	
	//category, name, opts
	foreach dressups.available; _dressup
	{
		_dressup = SPLIT(_dressup,C_BYTE1)
		
		_index = ASEARCH(_dressup[0],_category.key)
		
		//Add new category if none found
		if _index == -1
		{
			_category.key ,= _dressup[0]
			_category.val ,= _dressup[1]
			_category.opt ,= _dressup[2] //It's ok if this is an empty string...
		}
		else
		{
			_category.val[_index] += C_BYTE1 + _dressup[1]
		}
	}
	
	//—— Assign new dressups ——
	_skipratio = 4 //1 out of 4
	for _i = 0; _i < ARRAYSIZE(_category.key); _i++
	{
		_multiple = 0
		_mustselect = 0
		if "multiple" _in_ _category.opt[_i]; _multiple = 1
		if "mustselect" _in_ _category.opt[_i]; _mustselect = 1
		
		_category = _category.key[_i]
		if _currentcategory != "" //A category is assigned
		{
			if _currentcategory != _category; continue //Skip if not the correct one
		}
		else //No category
		{
			if !_mustselect && RAND(_skipratio) != 0; continue //Chance to skip if not mustselect
		}
		
		_dressups = SPLIT(_category.val[_i],C_BYTE1)
		
		_dressup_added = 0
		if _multiple
		{
			foreach _dressups; _dressup
			{
				if RAND(_skipratio) != 0
				{
					_dressup_added = 1
					"\![bind,%(_category),%(_dressup),1]"
				}
			}
		}
		
		//If this is a pick-one category, or it's multiple but no dressups were added
		if !_dressup_added
		{
			"\![bind,%(_category),%(ANY(_dressups)),1]"
		}
	}
	
	if _returnto != ""; "\![set,balloonwait,0.01] \![raise,%(_returnto),%(_currentcategory)]"
}